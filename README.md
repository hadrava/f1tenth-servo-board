# F1/10 ATmega servo-board

Firmware for motor controller board based on Arduino Mini PRO 328p. We use it
inside our robot for [F1/10 competition](http://www.f1tenth.org/) equiped with
brushed motor and standard Traxxas driver XL-5 ESC and receiver.

For developmment documentation, please have a look at [DEVEL.md](DEVEL.md).

## Main features

 - 2 output channels of 100 Hz RC servo PWM signal
   - Built-in simulation of Traxxas driver
     - This controller knows, wheter the driver is in brake on backward mode
     - Controller can automatically enforce any of desired modes
     - Tested with Traxxas XL-5 ESC
   - Output signal frequency can be easily changed during compile time (for example to 50 Hz)
 - UART interface
   - Default Baudrate: 115200
 - 2 input capture channels of RC servo PWM signal
   - Remote controller can be used in different modes:
     - `SB_REMOTE_ONLY`: Remote-only (receiver pass-through) -- Controller works as RC servo signal to UART sniffing device
     - `SB_SERIAL_ONLY`: UART-only (receiver ignored) -- Remote signals are still captured and can be processed by the main computer
     - `SB_TAKEOVER`: Take-over -- If remote controller is in stand-by, UART signals are passed to motors
       - User can fully take-over the controll at any time
       - This is our favourite mode, because you can remotely move the robot whenever it gets into dangerous position
     - `SB_TAKEOVER_WITH_TRIM`: Same as above, but steering commands from receiver are added to UART steering commands at all time
     - `SB_SPEED_LIMIT`: Speed limit: Maximal speed is limited by remote controller
       - This is the safest mode -- Motors can't rotate without somebody holding the remote controller throttle control
       - Note that steering is not affected by this
     - `SB_PAUSE`: Pause -- Controller can be in two substates: running on paused; states are switched by pressing the remote controller throttle
       - Usefull in certain situations during robot debugging -- the software can be fully running and you can simply disable the motors
     - `SB_REMOTE_STATE_DEMO`: Demonstration of speed controller simulation -- Traxxas driver is switched only between theese modes:
       - full-forward - if remote controller throttle is at least slightly pressed
       - full-brake - if remote controller throttle is in neutral
       - full-backward - if remote controller throttle is at least slightly in backward/brake position

## Hardware setup

Firmware was tested on chinese clone of Arduino Mini PRO 328p. It should work
on any ATmega 328p with 16 MHz external crystal and probably also on less
capable microcontrollers as well.

### Pinout

All pin-assignments are given by hardware capabilities:
 - Outputs are generated by Timer1 with PWM pins:
   - `PB1` (alternate function: `OC1A`, Arduino pin `13`): Steering
   - `PB2` (alternate function: `OC1B`, Arduino pin `14`): Throttle
   - (Pins can be swapped inside file `hw.h` by changing `OCR1_ANGLE` and `OCR1_SPEED` definitions.)
 - UART signals are handled directly by USART0 subsystem:
   - `PD0` (Arduino pin `30`): `RXD`
   - `PD1` (Arduino pin `31`): `TXD`
 - Input signals are using INT0 and INT1 interrupts:
   - `PD2` (alternate funcion: `INT0`, Arduino pin `32`): Steering
   - `PD3` (alternate funcion: `INT1`, Arduino pin `1`): Throttle
   - (Pins can be swapped inside file `hw.h` by changing all six definitions after `// Input capture signals mapping` comment.)

Additionally, we are using onboard LED output on pin `PB5` (Arduino pin `17`).
It is controlled only from `main(void)` function inside `main.c`. If you do not
want this behavior, please remove all three lines containing string `PB5`.

### Simple connection schema

The simplest way to connect is shown in the schema bellow. Just disconnect the
signals between reciever and motors and plug them to Arduino.
```
    +---------+
    | Battery |
    +---------+
       |  |
   VCC |  | GND
       |  |
+----------------+       +-------+
|                |-------|       |
| Traxxas driver |       | Motor |
|                |-------|       |
+----------------+       +-------+
5V |  GND |    |        Throttle signal
   |      |    +-------------------------------------+
   |      |                                          |
   |      |                                          |
   |      |    +---------------------------+         |
5V |  GND |    |        Throttle signal    |         |
+--------------------+          +----------------------------------+
|             CH2    |    5V    |       PD3(1)    PB2(14)          |  RXD
|                    |----------|RAW     Input    Output   PD0(30) |-------
| Traxxas receiver   |          |    Arduino PRO mini 328p         |
|                    |----------|GND     Input    Output   PD1(31) |-------
|             CH1    |    GND   |       PD2(32)   PB1(13)          |  TXD
+--------------------+          +----------------------------------+
5V |  GND |    |        Steering signal    |         |
   |      |    +---------------------------+         |
   |      |                                          |
   |      |                                          |
   |      |    +-------------------------------------+
5V |  GND |    |        Steering signal
 +----------------+
 | Steering servo |
 +----------------+

```

Note that the fast changes of direction of seering servo can cause noise on 5V
line. We were able to confuse the Traxxas driver in a a way, that it exits the
backward movement state. So it is better to power the Steering servo from
separate power source or not to fully trust the Traxxas driver simulation.

## Installation and flashing

Firmware is ment to be compiled using avr-gcc. You can use provided Makefile to
compile it and flash it to arduino board using avrdude.

On Debian, you will need following pacakges: `build-essential`, `gcc-avr` and
`avrdude`. You can simply install them by running following command as root:

```
apt install build-essential gcc-avr avrdude
```

To compile the code, navigate to source directory and run simple command:
```
make
```

It will compile into file `main.hex` which can be flashed using:
```
make flash
```
This assumes that your arduino is connected as `/dev/ttyUSB0`, you have read and
write acces to it (e.g. you are in group dialout on Debian) and there is
bootloader present on the microcontroller.

You can tweak all flashing-related settings inside the Makefile to match your
setup. Just look for `AVRDUDEFLAGS`.


## Serial protocol specification

Default serial baudrate is 115200. You can change it by defining macro `BAUD_RATE`
during compile time (see `uart.c`)

### Sending commands to the controller

Controller can be commanded using 9 bytes long packets:
 1. Each packet starts with ASCII character `B` (`0x42`)
 2. Lower byte of 16-bit throttle signal
 3. Upper byte of 16-bit throttle signal
 4. Lower byte of 16-bit steering signal
 5. Upper byte of 16-bit steering signal
 6. One byte of selected mode, see `sb_states.h` for definition (you can include it in your project)
 7. Timeout in 1/100 of second. If no valid packet is received in this timeframe, controller will automatically switch Throttle signal to neutral.
 8. Reserved for future versions of protocol, needs to be zero byte (`0x00`)
 9. Reserved for future versions of protocol, needs to be zero byte (`0x00`)

#### Throttle and steering

Throttle and steering signals are lenghts of pwm signal in microseconds, but they will be at first normalized by controller.
Use 1500 for neutral and straight direction, 1000 for maximum backward sped and 2000 for maximum forward speed.

Throttle signal 1501 is translated to the smallest possible throttle, that will make the car
move forward. Similary: 1499 means smallest possible backward speed.

Additionaly to this, you can instruct the controller to enforce backward or
brake mode (that only makes sense for all signals < 1500). To enforce Brake
state, set the highest bit to one. And to enforce Backward state, set second
highest bit to one. You can use following C functions to achieve this:

```
uint16_t enforce_brake(uint16_t throttle_us) {
	return throttle_us | 0x8000;
}
uint16_t enforce_backward(uint16_t throttle_us) {
	return throttle_us | 0x4000;
}
```

#### Timeout

Timeout is specified in number of periods of output servo signal. Default
compiled-in frequency is 100 Hz, so the timeout is in 1/100 of second.

Additionally to timeout specified inside packet, there is also compiled-in
(16-bit) timeout, which will make the controller transit to its default state.
(Look for `SERIAL_MODES_TIMEOUT` inside `main.c`.)

If you do not modify the source, the default state is `SB_REMOTE_ONLY` and
controller will transition to it after 10 seconds of serial inactivity.

Note, that this timeout applies only to states which expects serial control.
Timeout will not cause transition between states `SB_REMOTE_ONLY` and
`SB_REMOTE_STATE_DEMO`.

#### Example

All examples assumes, that the controller is connected via USB-to-serial
adapter (as `/dev/ttyUSB0`) and you have permissions to read and write it.
(You have to be in group dialout on Debian.)

Use following command to transition to the `SB_REMOTE_STATE_DEMO`:
```
# Set speed to 115200 andisable character translations
stty 115200 ignbrk -brkint -icrnl -imaxbel -opost -onlcr -isig -icanon -iexten -echo -echoe -echok -echoctl -echoke < /dev/ttyUSB0

# Switch controller mode to 0x20 (SB_REMOTE_STATE_DEMO)
printf 'B\x00\x00\x00\x00\x20\x00\x00\x00' > /dev/ttyUSB0
```

### Receiving information from the controller

Controller sends one 19 bytes long packet each output servo signal period (100 Hz):
 1. Each packet starts with ASCII character `S` (`0x53`)
 2. Current controller mode (lower 4 bits are used for sub-state representation, so use `(state & SB_MASK)` before comparision with constants.)
 3. Lower byte of raw output 16-bit throttle signal in microseconds, which will be send to the motors in this period
 4. Upper byte of raw output 16-bit throttle signal in microseconds, which will be send to the motors in this period
 5. Lower byte of raw output 16-bit steering signal in microseconds, which will be send to the motors in this period
 6. Upper byte of raw output 16-bit steering signal in microseconds, which will be send to the motors in this period
 7. Lower byte of measured 16-bit throttle signal from receiver (prior to any normalisation)
 8. Upper byte of measured 16-bit throttle signal from receiver (prior to any normalisation)
 9. Lower byte of measured 16-bit steering signal from receiver (prior to any normalisation)
 10. Upper byte of measured 16-bit steering signal from receiver (prior to any normalisation)
 11. Lower byte of counter which gets incremented by one each period
 12. Upper byte of counter which gets incremented by one each period
 13. Current state of Traxxas driver simulation
 14. Number of periods since last data from receiver were measured on throttle channel
 15. Number of periods since last data from receiver were measured on steering channel
 16. Lower byte of 16-bit counter of periods since last valid packet was received via serial line
 17. Upper byte of 16-bit counter of periods since last valid packet was received via serial line
 18. Lower byte of 16-bit variable debug, should be ignored
 19. Upper byte of 16-bit variable debug, should be ignored


#### State of Traxxas driver simulation

Traxxas driver can be in any of three states:
 - `0x01`: forward / neutral-1
 - `0x02`: brake
 - `0x04`: neutral-2 / backward

The driver implements some sort of filtering. To succesfully transit from one
state to another, we need something between 2 to 3 same signals. So sometimes
we cant be completely sure, if the driver is in that exact mode. We represent driver
state as a bit field and we may be in any (non-empty) subset of all possible states.

Because of implementation reasons, we are storing the information twice: Lower
four bits means in which state we were and upper four bits are telling us into
which state we are transiting. (But might not be there yet)

For practical application is usually best to apply logical OR to both parts and
look only at the result:

```
#include <stdbool.h>

bool are_we_certainly_braking(uint8_t state) {
	state = state | (state >> 4);
	state = state & 0x0F;
	return (state == 0x02);
}
bool are_we_certainly_moving_backward(uint8_t state) {
	state = state | (state >> 4);
	state = state & 0x0F;
	return (state == 0x04);
}
```

#### Example

To read and display raw packets from controller, use following command:

```
# Set speed to 115200 andisable character translations
stty 115200 ignbrk -brkint -icrnl -imaxbel -opost -onlcr -isig -icanon -iexten -echo -echoe -echok -echoctl -echoke < /dev/ttyUSB0

xxd -c 19 /dev/ttyUSB0
```

## Known issues

- Traxxas driver simulation expects that all signals are succesfully detected.
This may not be true if noise is present on 5V rail. This can easily happen
when steering servo motor is powered directly by Traxxas driver. We were able
to mittigate this issue by using separate power supply for steering servo. It
may also be sufficient to just add enough capacitors near the servo.

- Microcontroller can not achive precisely Baudrate 115200 when running on 16
MHz clock. You may have issues with receiving data from it with certain
UART-to-USB adpaters. Sometimes you can fix this by changing the power supply
for ATmega. You can also lower the communication speed for example to 76800.
But be sure, that the other end capable of handling that speed. See datasheet
for ATmega 328p, Section 17.11, Table 17-12 (on page 203) for more information
about clock timing errors at different speeds.
